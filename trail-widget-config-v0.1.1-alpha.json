{
  "html": "<div id=\"diy-container\">\n    <div class=\"info-panel\">\n        <div class=\"flex-between\">\n            <p id=\"currentPos\">ROV: </p>\n            <div class=\"d-flex\">\n                <button id=\"toggleViewMode\" class=\"v-btn v-btn--icon v-theme--dark v-btn--density-compact v-btn--size-default v-btn--variant-text mr-2\">\n                    <i class=\"mdi mdi-compass v-icon notranslate v-theme--dark v-icon--size-default\"></i>\n                </button>\n                <button id=\"clearTrail\" class=\"v-btn v-btn--icon v-theme--dark v-btn--density-compact v-btn--size-default v-btn--variant-text mr-2\" title=\"Clear Path History\">\n                    <i class=\"mdi mdi-eraser v-icon notranslate v-theme--dark v-icon--size-default\"></i>\n                </button>\n                <button id=\"importGpx\" class=\"v-btn v-btn--icon v-theme--dark v-btn--density-compact v-btn--size-default v-btn--variant-text mr-2\">\n                    <i class=\"mdi mdi-file-import v-icon notranslate v-theme--dark v-icon--size-default\"></i>\n                </button>\n                <button id=\"toggleTargetContainer\" class=\"v-btn v-btn--icon v-theme--dark v-btn--density-compact v-btn--size-default v-btn--variant-text add-new-target\">\n                    <i class=\"mdi mdi-chevron-up v-icon notranslate v-theme--dark v-icon--size-default\" id=\"targetChevron\"></i>\n                </button>\n                <input type=\"file\" id=\"gpxFileInput\" accept=\".gpx, .kml\" style=\"display:none\">\n            </div>\n            \n        </div>\n\n        <div id=\"targetContainer\">\n            <!-- Persistent New Target Input -->\n            <div id=\"newTargetInput\" class=\"target-input-group\">\n                <div class=\"v-input v-input--horizontal v-input--center-affix v-input--density-compact v-theme--light v-text-field\">\n                    <div class=\"v-input__control\">\n                        <div class=\"v-field v-field--active v-field--center-affix v-field--variant-outlined v-theme--light\">\n                            <div class=\"v-field__overlay\"></div>\n                            <div class=\"v-field__field\" data-no-activator=\"\">\n                                <label class=\"v-label v-field-label\">New Target</label>\n                                <input type=\"text\" class=\"v-field__input newTargetCoords\" autocomplete=\"off\">\n                            </div>\n                            <div class=\"v-field__outline\">\n                                <div class=\"v-field__outline__start\"></div>\n                                <div class=\"v-field__outline__notch\">\n                                    <label class=\"v-label v-field-label v-field-label--floating\">New Target</label>\n                                </div>\n                                <div class=\"v-field__outline__end\"></div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n                <button type=\"button\" class=\"v-btn v-btn--icon v-theme--dark v-btn--density-compact v-btn--size-default v-btn--variant-text add-new-target\">\n                    <i class=\"mdi-plus mdi v-icon notranslate v-theme--dark v-icon--size-default\"></i>    \n                </button>\n            </div>\n            <!-- Container for Added Targets -->\n            <div id=\"addedTargetsContainer\"></div>\n\n            <div class=\"flex-between\">\n                <div>\n                    <!-- <p>Clear Points</p> -->\n                </div>\n                <div class=\"d-flex\">\n                    <button id=\"clearTargets\" class=\"v-btn v-btn--icon v-theme--dark v-btn--density-compact v-btn--size-default v-btn--variant-text mr-2\" title=\"Clear All Targets\">\n                        <i class=\"mdi mdi-map-marker-remove v-icon notranslate v-theme--dark v-icon--size-default\"></i>\n                    </button>\n                </div>\n            </div>\n            \n        </div>\n    </div>\n    \n    \n    <div id=\"mapContainer\">\n        <canvas id=\"mapCanvas\"></canvas>\n    </div>\n    \n</div>",
  "css": "#diy-container {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n    padding: 8px;\n    color: var(--v-theme-on-surface);\n    color: rgb(255, 255, 255);\n    height: 100%;\n    width: 100%;\n    \n}\n\n.info-panel {\n    background: var(--v-theme-surface);\n    background-color: rgba(255, 255, 255, 0.2);\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 4px 4px 0px, rgba(0, 0, 0, 0.086) 0px 8px 12px 6px;\n    border: 1px solid rgba(255, 255, 255, 0.08);\n    backdrop-filter: blur(25px);    \n    padding: 10px;\n}\n\n#mapContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100%;\n    width: 100%;\n    min-height: 200px;\n    min-width: 200px;\n}\n\n#mapCanvas {\n    border: 1px solid var(--v-border-color);\n    border-radius: 4px;\n    touch-action: none;\n    user-select: none;\n    -webkit-user-select: none;\n    cursor: grab;\n    background: transparent;\n    overflow: hidden;\n    box-shadow: inset 0 0 16px rgba(0, 0, 0, 0.2);\n}\n\n#mapCanvas:active {\n    cursor: grabbing;\n}\n\n/* Position display styles */\n#currentPos,\n#pixelCurrentPos,\n#firstPos {\n    font-family: var(--v-font-family);\n    font-size: 20px;\n    line-height: 1.5;\n    margin: 4px 0;\n}\n\n#targetContainer {\n    margin-top: 8px;\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n}\n\n.target-input-group {\n    display: flex;\n    flex-wrap: wrap;\n    align-items: center;\n    margin: 0;\n    margin-top: 8px;\n}\n\n/* Ensure the input takes available space */\n.target-input-group .v-input {\n    flex: 1 1 200px; /* try to keep a minimum width */\n}\n\n/* The buttons remain their natural size */\n.target-input-group button {\n    flex: 0 0 auto;\n}\n\n/* Optionally, you can force the buttons to wrap on a new line if needed */\n@media (max-width: 400px) {\n    .target-input-group {\n        flex-direction: column;\n        align-items: stretch;\n    }\n}\n\n.target-entry {\n    width: 100%;\n}\n\n.flex-between {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n}\n\n#addedTargetsContainer{\n    gap: 8px;\n}\n\n.canvas-stack {\n    position: relative;\n    width: 100%;\n    height: 100%;\n}\n\n.map-canvas-layer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    border: 1px solid var(--v-border-color);\n    border-radius: 4px;\n    touch-action: none;\n    user-select: none;\n    -webkit-user-select: none;\n    cursor: grab;\n    background: transparent;\n    overflow: hidden;\n    box-shadow: inset 0 0 16px rgba(0, 0, 0, 0.2);\n}\n\n.map-canvas-layer:active {\n    cursor: grabbing;\n}",
  "js": "const ROVMap = (() => {\n  const canvas = document.getElementById(\"mapCanvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const positionDisplay = document.getElementById(\"currentPos\");\n  const mapContainer = document.getElementById(\"mapContainer\");\n\n  const CONSTANTS = {\n    MIN_DISTANCE: 0.5,\n    MAX_TRAIL_POINTS: 300,\n    EARTH_RADIUS: 111320,\n    BASE_SCALE: 20,\n    MIN_SCALE: 0.01,\n    MAX_SCALE: 20,\n    TARGET_REACHED_THRESHOLD: 1.0,\n    ROV_SIZE: 20,\n  };\n\n  const STYLES = {\n    COLORS: {\n      ROV: \"white\",\n      TRAIL: \"rgba(160, 0, 0, 1)\",\n      ACTIVE_TARGET_ICON: \"limegreen\",\n      INACTIVE_TARGET_ICON: \"white\",\n      TARGET_LINE: \"white\",\n      DISTANCE_LINE_PRIMARY: \"limegreen\",\n      DISTANCE_LINE_SECONDARY: \"#999999\",\n      // GRID: \"rgba(68, 68, 68, 0.5)\",\n      GRID: \"rgba(100, 100, 100, 1)\",\n      NORTH: \"#FF4444\",\n    },\n    LINES: {\n      TRAIL: 3,\n      TARGET: 5,\n      TARGET_LINE: 3,\n    },\n  };\n\n  const MAVLINK_VARS = {\n    LAT: \"GLOBAL_POSITION_INT/lat\",\n    LON: \"GLOBAL_POSITION_INT/lon\",\n    HDG: \"GLOBAL_POSITION_INT/hdg\",\n  };\n\n  let state = {\n    trail: [],\n    firstPoint: null,\n    currentHeading: 0,\n    currentPosition: { lat: null, lon: null },\n    targets: [],\n    activeTargetIndex: -1,\n    scale: 1,\n    gridOrigin: { lat: null, lon: null },\n    gridOffset: { x: 0, y: 0 },\n    lastPosition: { lat: null, lon: null },\n    viewMode: \"rov-up\",\n  };\n\n  let uiState = {\n    initialPinchDistance: 0,\n    lastScale: 1,\n  };\n\n  const helpers = {\n    resizeCanvas() {\n      canvas.width = mapContainer.clientWidth;\n      canvas.height = mapContainer.clientHeight;\n      render.requestDraw();\n    },\n    latLonToMeters(lat, lon, refLat, refLon) {\n      const latMeters = (lat - refLat) * CONSTANTS.EARTH_RADIUS;\n      const lonMeters =\n        (lon - refLon) *\n        CONSTANTS.EARTH_RADIUS *\n        Math.cos((refLat * Math.PI) / 180);\n      return { x: lonMeters, y: -latMeters };\n    },\n    metersToPixels(meters, scaleFactor = CONSTANTS.BASE_SCALE) {\n      return meters * scaleFactor;\n    },\n    worldToScreen(meters) {\n      return {\n        x: canvas.width / 2 + helpers.metersToPixels(meters.x) * state.scale,\n        y: canvas.height / 2 + helpers.metersToPixels(meters.y) * state.scale,\n      };\n    },\n    toScreenCoordinates(point, applyScale = true) {\n      if (!point || !point.x || !point.y) return null;\n\n      return {\n        x: canvas.width / 2 + point.x * (applyScale ? state.scale : 1),\n        y: canvas.height / 2 + point.y * (applyScale ? state.scale : 1),\n      };\n    },\n    getGridSpacing() {\n      const candidateSteps = [\n        1, 2.5, 5, 10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000,\n      ];\n      const minPixelSpacing = 60;\n      const effectiveScale = CONSTANTS.BASE_SCALE * state.scale;\n\n      for (let step of candidateSteps) {\n        if (step * effectiveScale >= minPixelSpacing) {\n          return step;\n        }\n      }\n      return candidateSteps[candidateSteps.length - 1];\n    },\n    setCookie(name, value, days) {\n      const d = new Date();\n      d.setTime(d.getTime() + days * 24 * 60 * 60 * 1000);\n      const expires = \"expires=\" + d.toUTCString();\n      document.cookie =\n        name + \"=\" + encodeURIComponent(value) + \";\" + expires + \";path=/\";\n    },\n    getCookie(name) {\n      const cname = name + \"=\";\n      const decodedCookie = decodeURIComponent(document.cookie);\n      const ca = decodedCookie.split(\";\");\n      for (let c of ca) {\n        while (c.charAt(0) === \" \") {\n          c = c.substring(1);\n        }\n        if (c.indexOf(cname) === 0) {\n          return c.substring(cname.length, c.length);\n        }\n      }\n      return \"\";\n    },\n    drawMarker(ctx, x, y, size, color, lineWidth) {\n      this.drawLine(ctx, x - size, y - size, x + size, y + size, {\n        color,\n        width: lineWidth,\n      });\n      this.drawLine(ctx, x + size, y - size, x - size, y + size, {\n        color,\n        width: lineWidth,\n      });\n    },\n\n    drawLine(ctx, startX, startY, endX, endY, style = {}) {\n      ctx.save();\n      ctx.strokeStyle = style.color || STYLES.COLORS.TRAIL;\n      ctx.lineWidth = style.width || STYLES.LINES.TRAIL;\n      if (style.shadow) {\n        ctx.shadowColor = style.shadowColor || \"rgba(0, 0, 0, 0.5)\";\n        ctx.shadowBlur = style.shadowBlur || 10;\n      }\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n      ctx.restore();\n    },\n  };\n\n  const geoUtils = {\n    latLonToScreenPos(pos, applyScale = true) {\n      const ref = state.currentPosition;\n\n      const latMeters = (pos.lat - ref.lat) * CONSTANTS.EARTH_RADIUS;\n      const lonMeters =\n        (pos.lon - ref.lon) *\n        CONSTANTS.EARTH_RADIUS *\n        Math.cos((ref.lat * Math.PI) / 180);\n\n      const x = lonMeters * CONSTANTS.BASE_SCALE;\n      const y = -latMeters * CONSTANTS.BASE_SCALE;\n\n      return {\n        x: canvas.width / 2 + x * (applyScale ? state.scale : 1),\n        y: canvas.height / 2 + y * (applyScale ? state.scale : 1),\n      };\n    },\n\n    getDistance(pos1, pos2) {\n      if (!pos1 || !pos2) return 0;\n\n      const latDiff = (pos1.lat - pos2.lat) * CONSTANTS.EARTH_RADIUS;\n      const lonDiff =\n        (pos1.lon - pos2.lon) *\n        CONSTANTS.EARTH_RADIUS *\n        Math.cos(((pos1.lat + pos2.lat) / 2) * (Math.PI / 180));\n\n      return Math.sqrt(latDiff * latDiff + lonDiff * lonDiff);\n    },\n\n    getBearing(from, to) {\n      const dLon = (to.lon - from.lon) * (Math.PI / 180);\n      const y = Math.sin(dLon) * Math.cos(to.lat * (Math.PI / 180));\n      const x =\n        Math.cos(from.lat * (Math.PI / 180)) *\n          Math.sin(to.lat * (Math.PI / 180)) -\n        Math.sin(from.lat * (Math.PI / 180)) *\n          Math.cos(to.lat * (Math.PI / 180)) *\n          Math.cos(dLon);\n      const bearing = Math.atan2(y, x) * (180 / Math.PI);\n      return (bearing + 360) % 360;\n    },\n\n    isTargetVisible(target, padding = 50) {\n      const pos = this.latLonToScreenPos(target, false);\n      if (!pos) return false;\n\n      const scaledX = pos.x * state.scale;\n      const scaledY = pos.y * state.scale;\n\n      const diagonal = Math.sqrt(\n        Math.pow(canvas.width / 2, 2) + Math.pow(canvas.height / 2, 2)\n      );\n\n      const distance = Math.sqrt(scaledX * scaledX + scaledY * scaledY);\n      return distance < diagonal + padding;\n    },\n  };\n\n  const targets = {\n    saveTargets() {\n      helpers.setCookie(\n        \"cockpit-trail-widget-targets\",\n        JSON.stringify(state.targets),\n        365\n      );\n    },\n    loadTargets() {\n      const cookieVal = helpers.getCookie(\"cockpit-trail-widget-targets\");\n      if (cookieVal) {\n        try {\n          state.targets = JSON.parse(cookieVal);\n          if (state.targets && state.targets.length > 0) {\n            state.activeTargetIndex = 0;\n            const container = document.getElementById(\"addedTargetsContainer\");\n            container.innerHTML = \"\";\n            state.targets.forEach((target, index) => {\n              targets.createTargetEntry(index);\n            });\n          }\n        } catch (e) {\n          console.error(\"Error parsing targets cookie\", e);\n        }\n      }\n    },\n    createTargetEntry(index) {\n      const inputGroup = document.createElement(\"div\");\n      inputGroup.className = \"target-input-group\";\n      inputGroup.dataset.index = index;\n      inputGroup.innerHTML = `\n      <div class=\"target-entry\" style=\"display: flex; align-items: center;\">\n        <div class=\"v-btn v-btn--icon v-theme--dark v-btn--density-compact v-btn--size-small v-btn--variant-text drag-handle mr-2\">\n          <i class=\"mdi-drag-vertical mdi v-icon notranslate v-theme--dark v-icon--size-default\"></i>\n        </div>\n        <div class=\"v-input v-input--horizontal v-input--center-affix v-input--density-compact v-theme--light v-text-field\" style=\"flex-grow: 1;\">\n          <div class=\"v-input__control\">\n            <div class=\"v-field v-field--active v-field--center-affix v-field--variant-outlined v-theme--light\">\n              <div class=\"v-field__overlay\"></div>\n              <div class=\"v-field__field\" data-no-activator>\n                <label class=\"v-label v-field-label\">Target ${index + 1}</label>\n                <input type=\"text\" class=\"v-field__input targetCoords\">\n              </div>\n              <div class=\"v-field__outline\">\n                <div class=\"v-field__outline__start\"></div>\n                <div class=\"v-field__outline__notch\">\n                  <label class=\"v-label v-field-label v-field-label--floating\">Target ${\n                    index + 1\n                  }</label>\n                </div>\n                <div class=\"v-field__outline__end\"></div>\n              </div>\n            </div>\n          </div>\n        </div>\n        <button type=\"button\" class=\"v-btn v-btn--icon v-theme--dark v-btn--density-compact v-btn--size-default v-btn--variant-text select-target mx-2\">\n          <i class=\"mdi-target mdi v-icon notranslate v-theme--dark v-icon--size-default\"></i>\n        </button>\n        <button type=\"button\" class=\"v-btn v-btn--icon v-theme--dark v-btn--density-compact v-btn--size-default v-btn--variant-text remove-target\">\n          <i class=\"mdi-close mdi v-icon notranslate v-theme--dark v-icon--size-default\"></i>\n        </button>\n      </div>\n    `;\n\n      const targetInput = inputGroup.querySelector(\".targetCoords\");\n      targetInput.value = `${state.targets[index].lat}, ${state.targets[index].lon}`;\n\n      targetInput.addEventListener(\"keypress\", (event) => {\n        if (event.key === \"Enter\") {\n          const value = targetInput.value;\n          const coords = value.split(\",\");\n          if (coords.length !== 2) {\n            console.log(\"Invalid coordinate format. Use lat,lon\");\n            return;\n          }\n          const lat = parseFloat(coords[0].trim());\n          const lon = parseFloat(coords[1].trim());\n          if (isNaN(lat) || isNaN(lon)) {\n            console.log(\"Invalid coordinates\");\n            return;\n          }\n          state.targets[index] = { lat, lon };\n          targetInput.value = `${lat}, ${lon}`;\n          render.requestDraw();\n          targets.saveTargets();\n        }\n      });\n\n      document.getElementById(\"addedTargetsContainer\").appendChild(inputGroup);\n      targets.setupTargetEntryListeners(inputGroup, index);\n      targets.setupDragForElement(inputGroup);\n    },\n\n    setupDragAndDrop() {\n      const targetContainer = document.getElementById(\"addedTargetsContainer\");\n\n      const observer = new MutationObserver((mutations) => {\n        for (let mutation of mutations) {\n          if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n            mutation.addedNodes.forEach((node) => {\n              if (\n                node.classList &&\n                node.classList.contains(\"target-input-group\")\n              ) {\n                this.setupDragForElement(node);\n              }\n            });\n          }\n        }\n      });\n\n      observer.observe(targetContainer, { childList: true });\n    },\n\n    setupDragForElement(element) {\n      const dragHandle = element.querySelector(\".drag-handle\");\n      if (!dragHandle) return;\n\n      dragHandle.style.cursor = \"grab\";\n\n      let draggedElement = null;\n      let startY = 0;\n      let startIndex = 0;\n\n      const handleMouseMove = (e) => {\n        if (!draggedElement) return;\n\n        const container = document.getElementById(\"addedTargetsContainer\");\n        const children = Array.from(container.children);\n\n        const currentY = e.clientY;\n\n        const targetElements = children.filter((el) => el !== draggedElement);\n        let swapWith = null;\n\n        targetElements.forEach((el) => {\n          const box = el.getBoundingClientRect();\n          const centerY = box.top + box.height / 2;\n\n          if (currentY < centerY && currentY > box.top) {\n            swapWith = el;\n          } else if (currentY > centerY && currentY < box.bottom) {\n            swapWith = el;\n          }\n        });\n\n        if (swapWith) {\n          const newIndex = parseInt(swapWith.dataset.index);\n\n          [state.targets[startIndex], state.targets[newIndex]] = [\n            state.targets[newIndex],\n            state.targets[startIndex],\n          ];\n\n          targets.compactTargets();\n          targets.saveTargets();\n\n          draggedElement = document.querySelector(\n            `.target-input-group[data-index=\"${newIndex}\"]`\n          );\n          draggedElement.classList.add(\"target-dragging\");\n          startIndex = newIndex;\n          startY = currentY;\n        }\n      };\n\n      const handleMouseUp = () => {\n        if (!draggedElement) return;\n\n        draggedElement.classList.remove(\"target-dragging\");\n        draggedElement = null;\n        document.body.style.cursor = \"\";\n\n        document.removeEventListener(\"mousemove\", handleMouseMove);\n        document.removeEventListener(\"mouseup\", handleMouseUp);\n\n        render.requestDraw();\n      };\n\n      const newDragHandle = dragHandle.cloneNode(true);\n      dragHandle.parentNode.replaceChild(newDragHandle, dragHandle);\n\n      newDragHandle.addEventListener(\"mousedown\", (e) => {\n        draggedElement = element;\n        startY = e.clientY;\n        startIndex = parseInt(element.dataset.index);\n\n        document.body.style.cursor = \"grabbing\";\n\n        element.classList.add(\"target-dragging\");\n\n        document.addEventListener(\"mousemove\", handleMouseMove);\n        document.addEventListener(\"mouseup\", handleMouseUp);\n\n        e.preventDefault();\n      });\n    },\n\n    setupTargetEntryListeners(inputGroup, index) {\n      const selectBtn = inputGroup.querySelector(\".select-target\");\n      const removeBtn = inputGroup.querySelector(\".remove-target\");\n\n      selectBtn.addEventListener(\"click\", () => {\n        state.activeTargetIndex = index;\n        render.requestDraw();\n      });\n\n      removeBtn.addEventListener(\"click\", () => {\n        state.targets.splice(index, 1);\n        targets.compactTargets();\n        render.requestDraw();\n        targets.saveTargets();\n      });\n    },\n\n    compactTargets() {\n      state.targets = state.targets.filter((target) => target !== null);\n\n      const container = document.getElementById(\"addedTargetsContainer\");\n      container.innerHTML = \"\";\n\n      state.targets.forEach((target, index) => {\n        targets.createTargetEntry(index);\n        const targetSpan = container.querySelector(\n          `.target-input-group[data-index=\"${index}\"] .targetCoords`\n        );\n        if (targetSpan) {\n          targetSpan.textContent = `${target.lat}, ${target.lon}`;\n        }\n      });\n\n      if (state.activeTargetIndex !== -1) {\n        state.activeTargetIndex = state.targets.findIndex(\n          (target, i) => i === state.activeTargetIndex\n        );\n      }\n    },\n\n    setupNewTargetInput() {\n      const newTargetGroup = document.getElementById(\"newTargetInput\");\n      const input = newTargetGroup.querySelector(\".newTargetCoords\");\n      const addBtn = newTargetGroup.querySelector(\".add-new-target\");\n\n      const submitNewTarget = () => {\n        const value = input.value;\n        const coords = value.split(\",\");\n        if (coords.length !== 2) {\n          console.log(\"Invalid coordinate format. Use lat,lon\");\n          return;\n        }\n        const lat = parseFloat(coords[0].trim());\n        const lon = parseFloat(coords[1].trim());\n        if (isNaN(lat) || isNaN(lon)) {\n          console.log(\"Invalid coordinates\");\n          return;\n        }\n        const newIndex = state.targets.length;\n        state.targets.push({ lat, lon });\n        targets.createTargetEntry(newIndex);\n        state.activeTargetIndex = newIndex;\n        render.requestDraw();\n        input.value = \"\";\n        targets.saveTargets();\n      };\n\n      addBtn.addEventListener(\"click\", submitNewTarget);\n      input.addEventListener(\"keypress\", (event) => {\n        if (event.key === \"Enter\") {\n          event.preventDefault();\n          submitNewTarget();\n        }\n      });\n    },\n\n    addDragStyles() {\n      const style = document.createElement(\"style\");\n      style.textContent = `\n      .target-dragging {\n        opacity: 0.8;\n        background-color: rgba(0, 0, 0, 0.1);\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n        position: relative;\n        z-index: 1000;\n        transition: transform 0.1s;\n      }\n      .drag-handle {\n        cursor: grab;\n      }\n      .drag-handle:active {\n        cursor: grabbing;\n      }\n      `;\n      document.head.appendChild(style);\n    },\n  };\n\n  const render = {\n    animationFrameId: null,\n    updatePending: false,\n    fps: 10, // Target frame rate\n    lastFrameTime: 0,\n\n    startAnimationLoop() {\n      const frameInterval = 1000 / this.fps;\n\n      const animationLoop = (timestamp) => {\n        const elapsed = timestamp - this.lastFrameTime;\n\n        const shouldDraw = elapsed >= frameInterval || this.updatePending;\n        if (shouldDraw) {\n          this.lastFrameTime = timestamp - (elapsed % frameInterval);\n          this.draw();\n          this.updatePending = false;\n        }\n        this.animationFrameId = requestAnimationFrame(animationLoop);\n      };\n\n      this.animationFrameId = requestAnimationFrame(animationLoop);\n    },\n\n    stopAnimationLoop() {\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n    },\n\n    requestDraw() {\n      // this.updatePending = true;\n    },\n\n    applyViewRotation(drawingFunction) {\n      ctx.save();\n      ctx.translate(canvas.width / 2, canvas.height / 2);\n\n      // Only apply heading rotation in 'rov-up' mode\n      if (state.viewMode === \"rov-up\") {\n        ctx.rotate(-state.currentHeading * (Math.PI / 180));\n      }\n\n      ctx.translate(-canvas.width / 2, -canvas.height / 2);\n\n      // Execute the provided drawing function\n      drawingFunction();\n\n      ctx.restore();\n    },\n\n    draw() {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      this.drawGrid();\n      this.drawTrailPath();\n      this.drawTargets();\n      this.drawROV();\n      this.drawScaleIndicator();\n    },\n\n    drawROV() {\n      ctx.save();\n      ctx.translate(canvas.width / 2, canvas.height / 2);\n\n      // In north-up mode, we need to rotate the ROV icon to match its heading\n      if (state.viewMode === \"north-up\") {\n        ctx.rotate(state.currentHeading * (Math.PI / 180));\n      }\n\n      ctx.shadowColor = \"rgba(0, 0, 0, 0.5)\";\n      ctx.shadowBlur = 30;\n      ctx.beginPath();\n      ctx.moveTo(0, -CONSTANTS.ROV_SIZE);\n      ctx.lineTo(CONSTANTS.ROV_SIZE, CONSTANTS.ROV_SIZE);\n      ctx.lineTo(0, CONSTANTS.ROV_SIZE / 2);\n      ctx.lineTo(-CONSTANTS.ROV_SIZE, CONSTANTS.ROV_SIZE);\n      ctx.closePath();\n      ctx.fillStyle = STYLES.COLORS.ROV;\n      ctx.fill();\n\n      // Save context again before drawing north indicator\n      ctx.save();\n\n      // If in north-up mode, counter-rotate to keep north indicator steady\n      if (state.viewMode === \"north-up\") {\n        ctx.rotate(-state.currentHeading * (Math.PI / 180));\n      }\n\n      // Now draw the north indicator (will be fixed in north-up mode)\n      const northAngle = -state.currentHeading * (Math.PI / 180);\n      const northLength = 55;\n      const northX = Math.sin(northAngle) * northLength;\n      const northY = -Math.cos(northAngle) * northLength;\n\n      // In north-up mode, north always points up\n      if (state.viewMode === \"north-up\") {\n        helpers.drawLine(ctx, 0, 0, 0, -northLength, {\n          color: STYLES.COLORS.NORTH,\n          width: 3.5,\n        });\n\n        // Arrow for north indicator\n        const arrowWidth = 12;\n        ctx.beginPath();\n        ctx.fillStyle = STYLES.COLORS.NORTH;\n        ctx.moveTo(0, -northLength);\n        ctx.lineTo(-arrowWidth / 2, -northLength + 10);\n        ctx.lineTo(arrowWidth / 2, -northLength + 10);\n        ctx.closePath();\n        ctx.fill();\n\n        // \"N\" label\n        ctx.fillStyle = STYLES.COLORS.NORTH;\n        ctx.font = \"bold 16px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"N\", 0, -northLength - 10);\n      } else {\n        // Original north indicator for ROV-up mode\n        helpers.drawLine(ctx, 0, 0, northX, northY, {\n          color: STYLES.COLORS.NORTH,\n          width: 3.5,\n        });\n\n        // Arrow\n        const arrowLength = 10;\n        const arrowWidth = 12;\n        ctx.beginPath();\n        ctx.fillStyle = STYLES.COLORS.NORTH;\n        ctx.moveTo(northX, northY);\n        const baseX = northX - Math.sin(northAngle) * arrowLength;\n        const baseY = northY + Math.cos(northAngle) * arrowLength;\n        const perpAngle = northAngle + Math.PI / 2;\n        const offsetX = (Math.sin(perpAngle) * arrowWidth) / 2;\n        const offsetY = (-Math.cos(perpAngle) * arrowWidth) / 2;\n        ctx.lineTo(baseX + offsetX, baseY + offsetY);\n        ctx.lineTo(baseX - offsetX, baseY - offsetY);\n        ctx.closePath();\n        ctx.fill();\n\n        // \"N\" label\n        ctx.fillStyle = STYLES.COLORS.NORTH;\n        ctx.font = \"bold 16px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        const labelDistance = northLength + 10;\n        const labelX = Math.sin(northAngle) * labelDistance;\n        const labelY = -Math.cos(northAngle) * labelDistance;\n        ctx.fillText(\"N\", labelX, labelY);\n      }\n\n      // Restore context after drawing north indicator\n      ctx.restore();\n      ctx.restore();\n    },\n\n    drawTrailPath() {\n      if (\n        !state.currentPosition.lat ||\n        !state.currentPosition.lon ||\n        state.trail.length < 2\n      ) {\n        return;\n      }\n\n      this.applyViewRotation(() => {\n        ctx.save();\n        try {\n          // Set common style once\n          ctx.strokeStyle = STYLES.COLORS.TRAIL;\n          ctx.lineWidth = STYLES.LINES.TRAIL;\n          ctx.beginPath();\n\n          // Cache the first point\n          const firstPoint = geoUtils.latLonToScreenPos(state.trail[0], true);\n          if (!firstPoint) return;\n\n          ctx.moveTo(firstPoint.x, firstPoint.y);\n\n          // Draw all segments in one path\n          for (let i = 1; i < state.trail.length; i++) {\n            const currentPoint = geoUtils.latLonToScreenPos(\n              state.trail[i],\n              true\n            );\n            if (!currentPoint) continue;\n\n            ctx.lineTo(currentPoint.x, currentPoint.y);\n          }\n\n          ctx.stroke();\n        } finally {\n          ctx.restore();\n        }\n      });\n    },\n\n    drawTargets() {\n      if (\n        !state.firstPoint ||\n        !state.targets.length ||\n        !state.currentPosition.lat ||\n        !state.currentPosition.lon\n      )\n        return;\n\n      this.applyViewRotation(() => {\n        this._drawTargetConnections();\n        this._drawActiveTargetLine();\n        this._drawPreviousTargetLine();\n        this._drawTargetMarkers();\n      });\n    },\n\n    _drawLineWithTextGap(start, end, textPosition, style = {}) {\n      const dx = end.x - start.x;\n      const dy = end.y - start.y;\n      const textDist = Math.sqrt(\n        Math.pow(textPosition.x - start.x, 2) +\n          Math.pow(textPosition.y - start.y, 2)\n      );\n      const totalDist = Math.sqrt(dx * dx + dy * dy);\n      const dirX = dx / totalDist;\n      const dirY = dy / totalDist;\n      const gapSize = 25;\n      const gapStart = {\n        x: textPosition.x - gapSize * dirX,\n        y: textPosition.y - gapSize * dirY,\n      };\n      const gapEnd = {\n        x: textPosition.x + gapSize * dirX,\n        y: textPosition.y + gapSize * dirY,\n      };\n\n      ctx.beginPath();\n      if (style.dashed) {\n        ctx.setLineDash(style.dashed);\n      } else {\n        ctx.setLineDash([]);\n      }\n      ctx.strokeStyle = style.color || STYLES.COLORS.DISTANCE_LINE_PRIMARY;\n      ctx.lineWidth = style.width || STYLES.LINES.TARGET_LINE;\n\n      ctx.moveTo(start.x, start.y);\n      ctx.lineTo(gapStart.x, gapStart.y);\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.moveTo(gapEnd.x, gapEnd.y);\n      ctx.lineTo(end.x, end.y);\n      ctx.stroke();\n\n      ctx.setLineDash([]);\n    },\n\n    _drawTargetConnections() {\n      ctx.beginPath();\n      ctx.strokeStyle = \"#999999\";\n      ctx.lineWidth = STYLES.LINES.TARGET_LINE;\n\n      state.targets.forEach((target, index) => {\n        if (!target) return;\n        const screenPos = geoUtils.latLonToScreenPos(target);\n\n        if (index > 0 && state.targets[index - 1]) {\n          const prevScreenPos = geoUtils.latLonToScreenPos(\n            state.targets[index - 1]\n          );\n\n          helpers.drawLine(\n            ctx,\n            prevScreenPos.x,\n            prevScreenPos.y,\n            screenPos.x,\n            screenPos.y,\n            {\n              color: STYLES.COLORS.TARGET_LINE,\n              width: STYLES.LINES.TARGET_LINE,\n            }\n          );\n        }\n      });\n    },\n\n    _drawTargetLine(targetIndex, lineColor, textColor) {\n      if (\n        targetIndex === -1 ||\n        !state.targets[targetIndex] ||\n        !state.currentPosition.lat ||\n        !state.currentPosition.lon\n      )\n        return;\n\n      const target = state.targets[targetIndex];\n      const scaledTarget = geoUtils.latLonToScreenPos(target);\n      const currentPixels = { x: canvas.width / 2, y: canvas.height / 2 };\n\n      const { lineEndPoint, textPosition, angle } =\n        this._calculateLineEndpoints(currentPixels, scaledTarget);\n\n      ctx.beginPath();\n      ctx.strokeStyle = lineColor;\n      ctx.lineWidth = STYLES.LINES.TARGET_LINE;\n      ctx.setLineDash([5, 5]);\n      ctx.moveTo(currentPixels.x, currentPixels.y);\n      ctx.lineTo(lineEndPoint.x, lineEndPoint.y);\n      ctx.stroke();\n      ctx.setLineDash([]);\n\n      const distanceMeters = geoUtils.getDistance(\n        state.currentPosition,\n        target\n      );\n      this._drawDistanceLabel(textPosition, distanceMeters, textColor, angle);\n    },\n\n    _drawActiveTargetLine() {\n      this._drawTargetLine(\n        state.activeTargetIndex,\n        STYLES.COLORS.DISTANCE_LINE_PRIMARY,\n        STYLES.COLORS.DISTANCE_LINE_PRIMARY\n      );\n    },\n\n    _drawPreviousTargetLine() {\n      if (state.activeTargetIndex === -1 || state.targets.length <= 1) return;\n\n      const prevIndex =\n        (state.activeTargetIndex - 1 + state.targets.length) %\n        state.targets.length;\n\n      if (prevIndex === state.activeTargetIndex) return;\n\n      this._drawTargetLine(\n        prevIndex,\n        STYLES.COLORS.DISTANCE_LINE_SECONDARY,\n        STYLES.COLORS.DISTANCE_LINE_SECONDARY\n      );\n    },\n\n    _calculateLineEndpoints(start, end) {\n      const dx = end.x - start.x;\n      const dy = end.y - start.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      const angle = Math.atan2(dy, dx);\n\n      if (distance < 10) {\n        return {\n          lineEndPoint: end,\n          textPosition: {\n            x: (start.x + end.x) / 2 + 20,\n            y: (start.y + end.y) / 2 - 10,\n          },\n          angle: angle,\n        };\n      }\n\n      const dirX = dx / distance;\n      const dirY = dy / distance;\n\n      // Calculate perpendicular direction for text offset\n      const perpX = -dirY;\n      const perpY = dirX;\n      const offsetDistance = 30; // Offset distance from line\n\n      const diagonal =\n        Math.sqrt(Math.pow(canvas.width, 2) + Math.pow(canvas.height, 2)) / 2;\n      const isTargetVisible = distance < diagonal;\n\n      let lineEndPoint;\n      if (isTargetVisible) {\n        lineEndPoint = { x: end.x, y: end.y };\n      } else {\n        const extendedDistance = diagonal * 1.5;\n        lineEndPoint = {\n          x: start.x + dirX * extendedDistance,\n          y: start.y + dirY * extendedDistance,\n        };\n      }\n\n      const textDistance = isTargetVisible\n        ? distance / 2\n        : Math.min(distance / 2, diagonal / 2);\n\n      // Position text beside the line by adding perpendicular offset\n      const textPosition = {\n        x: start.x + dirX * textDistance + perpX * offsetDistance,\n        y: start.y + dirY * textDistance + perpY * offsetDistance,\n      };\n\n      return { lineEndPoint, textPosition, angle };\n    },\n\n    _drawDistanceLabel(position, distanceMeters, textColour, angle) {\n      const distanceText = distanceMeters.toFixed(1) + \" m\";\n      ctx.save();\n      ctx.translate(position.x, position.y);\n\n      if (state.viewMode === \"north-up\") {\n        ctx.rotate(0);\n      } else {\n        ctx.rotate(state.currentHeading * (Math.PI / 180));\n      }\n\n      ctx.font = \"bold 16px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      const textWidth = ctx.measureText(distanceText).width;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0.1)\";\n      ctx.fillRect(-textWidth / 2 - 4, -14, textWidth + 8, 28);\n      ctx.fillStyle = textColour;\n      ctx.fillText(distanceText, 0, 0);\n      ctx.restore();\n    },\n\n    _drawTargetMarkers() {\n      state.targets.forEach((target, index) => {\n        if (!target) return;\n\n        const screenPos = geoUtils.latLonToScreenPos(target);\n\n        const size = 12;\n        const color =\n          index === state.activeTargetIndex\n            ? STYLES.COLORS.ACTIVE_TARGET_ICON\n            : STYLES.COLORS.INACTIVE_TARGET_ICON;\n\n        helpers.drawMarker(\n          ctx,\n          screenPos.x,\n          screenPos.y,\n          size,\n          color,\n          STYLES.LINES.TARGET\n        );\n      });\n    },\n\n    drawGrid() {\n      if (!state.currentPosition.lat || !state.currentPosition.lon) return;\n\n      this.applyViewRotation(() => {\n        const gridParams = this._calculateGridParameters();\n        this._drawGridLines(ctx, gridParams);\n      });\n    },\n\n    _calculateGridParameters() {\n      const gridSpacing = helpers.getGridSpacing();\n      const effectiveMultiplier = CONSTANTS.BASE_SCALE * state.scale;\n\n      // Calculate grid boundaries with padding for rotation\n      const diagonal = Math.sqrt(\n        canvas.width * canvas.width + canvas.height * canvas.height\n      );\n      const extraPadding = diagonal / 2;\n\n      return {\n        gridSpacing,\n        effectiveMultiplier,\n        bounds: {\n          left: -(canvas.width / 2 + extraPadding) / effectiveMultiplier,\n          right: (canvas.width / 2 + extraPadding) / effectiveMultiplier,\n          top: -(canvas.height / 2 + extraPadding) / effectiveMultiplier,\n          bottom: (canvas.height / 2 + extraPadding) / effectiveMultiplier,\n        },\n        offset: {\n          x: state.gridOffset.x % gridSpacing,\n          y: state.gridOffset.y % gridSpacing,\n        },\n      };\n    },\n\n    _drawGridLines(ctx, params) {\n      const { gridSpacing, bounds, offset } = params;\n\n      ctx.beginPath();\n      ctx.strokeStyle = STYLES.COLORS.GRID;\n      ctx.lineWidth = 1;\n\n      const startX =\n        Math.floor(bounds.left / gridSpacing) * gridSpacing - offset.x;\n      const endX =\n        Math.ceil(bounds.right / gridSpacing) * gridSpacing - offset.x;\n\n      for (let x = startX; x <= endX; x += gridSpacing) {\n        const start = helpers.worldToScreen({ x, y: bounds.top });\n        const end = helpers.worldToScreen({ x, y: bounds.bottom });\n        ctx.moveTo(start.x, start.y);\n        ctx.lineTo(end.x, end.y);\n      }\n\n      const startY =\n        Math.floor(bounds.top / gridSpacing) * gridSpacing - offset.y;\n      const endY =\n        Math.ceil(bounds.bottom / gridSpacing) * gridSpacing - offset.y;\n\n      for (let y = startY; y <= endY; y += gridSpacing) {\n        const start = helpers.worldToScreen({ x: bounds.left, y });\n        const end = helpers.worldToScreen({ x: bounds.right, y });\n        ctx.moveTo(start.x, start.y);\n        ctx.lineTo(end.x, end.y);\n      }\n\n      ctx.stroke();\n    },\n\n    drawScaleIndicator() {\n      const gridSpacing = helpers.getGridSpacing();\n      const formattedValue =\n        gridSpacing >= 1000\n          ? (gridSpacing / 1000).toFixed(1) + \" km\"\n          : gridSpacing.toFixed(1) + \" m\";\n\n      const padding = 20;\n      const x = canvas.width - padding;\n      const y = canvas.height - padding;\n\n      ctx.save();\n      ctx.font = \"bold 20px Arial\";\n\n      ctx.fillStyle = STYLES.COLORS.GRID;\n      ctx.textAlign = \"right\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(formattedValue, x, y - 8);\n      ctx.restore();\n    },\n  };\n\n  const mavlink = {\n    handleLatitude() {\n      const lat =\n        window.cockpit.getDataLakeVariableData(MAVLINK_VARS.LAT) / 1e7;\n      if (lat === undefined) return;\n\n      state.currentPosition.lat = lat;\n      mavlink.updatePosition();\n    },\n\n    handleLongitude() {\n      const lon =\n        window.cockpit.getDataLakeVariableData(MAVLINK_VARS.LON) / 1e7;\n      if (lon === undefined) return;\n\n      state.currentPosition.lon = lon;\n      mavlink.updatePosition();\n    },\n\n    handleHeading() {\n      const heading =\n        window.cockpit.getDataLakeVariableData(MAVLINK_VARS.HDG) / 100;\n      if (heading === undefined) return;\n\n      state.currentHeading = heading;\n      render.requestDraw();\n    },\n\n    updatePosition() {\n      if (!state.currentPosition.lat || !state.currentPosition.lon) return;\n\n      const { lat, lon } = state.currentPosition;\n\n      if (!state.gridOrigin.lat) {\n        state.gridOrigin.lat = lat;\n        state.gridOrigin.lon = lon;\n      }\n\n      if (state.lastPosition.lat !== null) {\n        const movement = helpers.latLonToMeters(\n          lat,\n          lon,\n          state.lastPosition.lat,\n          state.lastPosition.lon\n        );\n        state.gridOffset.x += movement.x;\n        state.gridOffset.y += movement.y;\n      }\n\n      state.lastPosition.lat = lat;\n      state.lastPosition.lon = lon;\n\n      if (!state.firstPoint) {\n        state.firstPoint = { lat, lon };\n      }\n\n      if (\n        state.trail.length === 0 ||\n        geoUtils.getDistance(\n          { lat, lon },\n          state.trail[state.trail.length - 1]\n        ) >= CONSTANTS.MIN_DISTANCE\n      ) {\n        state.trail.push({ lat, lon });\n        if (state.trail.length > CONSTANTS.MAX_TRAIL_POINTS)\n          state.trail.shift();\n      }\n\n      positionDisplay.innerText = `ROV: ${lat.toFixed(7)}°, ${lon.toFixed(7)}°`;\n\n      this.checkTargetProximity();\n\n      render.requestDraw();\n    },\n\n    checkTargetProximity() {\n      if (\n        state.activeTargetIndex === -1 ||\n        !state.targets.length ||\n        !state.currentPosition.lat ||\n        !state.currentPosition.lon\n      ) {\n        return;\n      }\n\n      const currentTarget = state.targets[state.activeTargetIndex];\n      const distanceToTarget = geoUtils.getDistance(\n        state.currentPosition,\n        currentTarget\n      );\n\n      if (distanceToTarget <= CONSTANTS.TARGET_REACHED_THRESHOLD) {\n        console.log(\n          `Target ${\n            state.activeTargetIndex + 1\n          } reached! Distance: ${distanceToTarget.toFixed(2)}m`\n        );\n\n        state.activeTargetIndex =\n          (state.activeTargetIndex + 1) % state.targets.length;\n        console.log(`Moving to target ${state.activeTargetIndex + 1}`);\n\n        render.requestDraw();\n      }\n    },\n\n    setupListeners() {\n      window.cockpit.listenDataLakeVariable(\n        MAVLINK_VARS.LAT,\n        this.handleLatitude\n      );\n      window.cockpit.listenDataLakeVariable(\n        MAVLINK_VARS.LON,\n        this.handleLongitude\n      );\n      window.cockpit.listenDataLakeVariable(\n        MAVLINK_VARS.HDG,\n        this.handleHeading\n      );\n    },\n  };\n\n  const events = {\n    handleWheel(e) {\n      e.preventDefault();\n      const zoomFactor = 1.1;\n\n      if (e.deltaY < 0) {\n        state.scale *= zoomFactor;\n      } else {\n        state.scale /= zoomFactor;\n      }\n\n      state.scale = Math.max(\n        CONSTANTS.MIN_SCALE,\n        Math.min(state.scale, CONSTANTS.MAX_SCALE)\n      );\n      render.requestDraw();\n    },\n\n    handleTouchStart(e) {\n      if (e.touches.length === 2) {\n        const dx = e.touches[0].clientX - e.touches[1].clientX;\n        const dy = e.touches[0].clientY - e.touches[1].clientY;\n        uiState.initialPinchDistance = Math.sqrt(dx * dx + dy * dy);\n        uiState.lastScale = state.scale;\n      }\n    },\n\n    // Handle touch move for pinch zooming\n    handleTouchMove(e) {\n      if (e.touches.length === 2) {\n        e.preventDefault();\n\n        // Calculate pinch distance\n        const dx = e.touches[0].clientX - e.touches[1].clientX;\n        const dy = e.touches[0].clientY - e.touches[1].clientY;\n        const pinchDistance = Math.sqrt(dx * dx + dy * dy);\n\n        // Calculate new scale\n        const scaleFactor = pinchDistance / uiState.initialPinchDistance;\n        state.scale = uiState.lastScale * scaleFactor;\n\n        // Apply scale limits\n        state.scale = Math.max(\n          CONSTANTS.MIN_SCALE,\n          Math.min(state.scale, CONSTANTS.MAX_SCALE)\n        );\n\n        render.requestDraw();\n      }\n    },\n\n    // Handle double click to reset grid\n    handleDoubleClick() {\n      state.gridOffset = { x: 0, y: 0 };\n      if (state.currentPosition.lat) {\n        state.gridOrigin.lat = state.currentPosition.lat;\n        state.gridOrigin.lon = state.currentPosition.lon;\n      }\n      render.requestDraw();\n    },\n\n    // Handle target container toggle\n    handleToggleTargetContainer() {\n      const targetContainer = document.getElementById(\"targetContainer\");\n      const chevronIcon = document.getElementById(\"targetChevron\");\n\n      if (targetContainer.style.display === \"none\") {\n        targetContainer.style.display = \"block\";\n        chevronIcon.className =\n          \"mdi mdi-chevron-up v-icon notranslate v-theme--dark v-icon--size-default\";\n      } else {\n        targetContainer.style.display = \"none\";\n        chevronIcon.className =\n          \"mdi mdi-chevron-down v-icon notranslate v-theme--dark v-icon--size-default\";\n      }\n\n      helpers.resizeCanvas();\n    },\n\n    // Set up all event listeners\n    setupEventListeners() {\n      // Resize handling\n      window.addEventListener(\"resize\", helpers.resizeCanvas);\n\n      // Zooming with mousewheel\n      canvas.addEventListener(\"wheel\", this.handleWheel);\n\n      // Touch events for pinch zoom\n      canvas.addEventListener(\"touchstart\", this.handleTouchStart);\n      canvas.addEventListener(\"touchmove\", this.handleTouchMove);\n\n      // Double click to reset grid\n      canvas.addEventListener(\"dblclick\", this.handleDoubleClick);\n\n      const targetContainer = document.getElementById(\"targetContainer\");\n      const chevronIcon = document.getElementById(\"targetChevron\");\n\n      targetContainer.style.display = \"none\";\n      chevronIcon.className =\n        \"mdi mdi-chevron-down v-icon notranslate v-theme--dark v-icon--size-default\";\n\n      document\n        .getElementById(\"toggleTargetContainer\")\n        .addEventListener(\"click\", this.handleToggleTargetContainer);\n\n      // Clear trail button if it exists\n      const clearTrailBtn = document.getElementById(\"clearTrail\");\n      if (clearTrailBtn) {\n        clearTrailBtn.addEventListener(\"click\", () => {\n          state.trail = [];\n          render.requestDraw();\n        });\n      }\n\n      const clearTargetsBtn = document.getElementById(\"clearTargets\");\n      if (clearTargetsBtn) {\n        clearTargetsBtn.addEventListener(\"click\", () => {\n          state.targets = [];\n          state.activeTargetIndex = -1;\n          document.getElementById(\"addedTargetsContainer\").innerHTML = \"\";\n          targets.saveTargets();\n          render.requestDraw();\n        });\n      }\n\n      const viewModeBtn = document.getElementById(\"toggleViewMode\");\n      if (viewModeBtn) {\n        viewModeBtn.addEventListener(\"click\", () => {\n          state.viewMode = state.viewMode === \"rov-up\" ? \"north-up\" : \"rov-up\";\n          const icon = viewModeBtn.querySelector(\"i\");\n          if (icon) {\n            icon.className =\n              state.viewMode === \"rov-up\"\n                ? \"mdi mdi-compass v-icon notranslate v-theme--dark v-icon--size-default\"\n                : \"mdi mdi-navigation v-icon notranslate v-theme--dark v-icon--size-default\";\n          }\n\n          render.requestDraw();\n        });\n      }\n    },\n  };\n\n  const gpxImport = {\n    // Parse GPX or KML file and extract waypoints\n    parseFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n\n        reader.onload = (e) => {\n          const fileContent = e.target.result;\n          const fileExtension = file.name.split(\".\").pop().toLowerCase();\n\n          try {\n            if (fileExtension === \"gpx\") {\n              resolve(this.parseGPX(fileContent));\n            } else if (fileExtension === \"kml\") {\n              resolve(this.parseKML(fileContent));\n            } else if (fileExtension === \"kmz\") {\n              this.extractKMZ(fileContent)\n                .then((kmlContent) => resolve(this.parseKML(kmlContent)))\n                .catch(reject);\n            } else {\n              reject(new Error(\"Unsupported file format\"));\n            }\n          } catch (error) {\n            reject(error);\n          }\n        };\n\n        reader.onerror = () => {\n          reject(new Error(\"Error reading file\"));\n        };\n\n        reader.readAsText(file);\n      });\n    },\n\n    // Parse GPX content\n    parseGPX(gpxText) {\n      const parser = new DOMParser();\n      const gpxDoc = parser.parseFromString(gpxText, \"text/xml\");\n\n      // Check if parsing was successful\n      if (gpxDoc.documentElement.nodeName === \"parsererror\") {\n        throw new Error(\"Invalid GPX file\");\n      }\n\n      const waypoints = [];\n\n      // Extract waypoints (wpt elements)\n      const wptNodes = gpxDoc.getElementsByTagName(\"wpt\");\n      for (let i = 0; i < wptNodes.length; i++) {\n        const wpt = wptNodes[i];\n        const lat = parseFloat(wpt.getAttribute(\"lat\"));\n        const lon = parseFloat(wpt.getAttribute(\"lon\"));\n\n        if (!isNaN(lat) && !isNaN(lon)) {\n          let name = \"\";\n          const nameNode = wpt.getElementsByTagName(\"name\")[0];\n          if (nameNode && nameNode.textContent) {\n            name = nameNode.textContent;\n          }\n\n          waypoints.push({ lat, lon, name });\n        }\n      }\n\n      // Extract track points (trkpt elements) if no waypoints found\n      if (waypoints.length === 0) {\n        const trkptNodes = gpxDoc.getElementsByTagName(\"trkpt\");\n        for (let i = 0; i < trkptNodes.length; i++) {\n          const trkpt = trkptNodes[i];\n          const lat = parseFloat(trkpt.getAttribute(\"lat\"));\n          const lon = parseFloat(trkpt.getAttribute(\"lon\"));\n\n          if (!isNaN(lat) && !isNaN(lon)) {\n            waypoints.push({ lat, lon });\n          }\n        }\n      }\n\n      // Extract route points (rtept elements) if still no points found\n      if (waypoints.length === 0) {\n        const rteptNodes = gpxDoc.getElementsByTagName(\"rtept\");\n        for (let i = 0; i < rteptNodes.length; i++) {\n          const rtept = rteptNodes[i];\n          const lat = parseFloat(rtept.getAttribute(\"lat\"));\n          const lon = parseFloat(rtept.getAttribute(\"lon\"));\n\n          if (!isNaN(lat) && !isNaN(lon)) {\n            waypoints.push({ lat, lon });\n          }\n        }\n      }\n\n      return waypoints;\n    },\n\n    // Parse KML content\n    parseKML(kmlText) {\n      const parser = new DOMParser();\n      const kmlDoc = parser.parseFromString(kmlText, \"text/xml\");\n\n      // Check if parsing was successful\n      if (kmlDoc.documentElement.nodeName === \"parsererror\") {\n        throw new Error(\"Invalid KML file\");\n      }\n\n      const waypoints = [];\n\n      // Extract Placemarks\n      const placemarks = kmlDoc.getElementsByTagName(\"Placemark\");\n      for (let i = 0; i < placemarks.length; i++) {\n        const placemark = placemarks[i];\n\n        // Get name if available\n        let name = \"\";\n        const nameNode = placemark.getElementsByTagName(\"name\")[0];\n        if (nameNode && nameNode.textContent) {\n          name = nameNode.textContent;\n        }\n\n        // Check for Point coordinates\n        const points = placemark.getElementsByTagName(\"Point\");\n        if (points.length > 0) {\n          const coordsNode = points[0].getElementsByTagName(\"coordinates\")[0];\n          if (coordsNode && coordsNode.textContent) {\n            const coordStr = coordsNode.textContent.trim();\n            const coords = coordStr.split(\",\");\n\n            if (coords.length >= 2) {\n              const lon = parseFloat(coords[0]);\n              const lat = parseFloat(coords[1]);\n\n              if (!isNaN(lat) && !isNaN(lon)) {\n                waypoints.push({ lat, lon, name });\n              }\n            }\n          }\n          continue; // Skip to next placemark if we found a point\n        }\n\n        // Check for LineString or LinearRing coordinates\n        const lineTypes = [\"LineString\", \"LinearRing\"];\n        for (const lineType of lineTypes) {\n          const lines = placemark.getElementsByTagName(lineType);\n          if (lines.length > 0) {\n            const coordsNode = lines[0].getElementsByTagName(\"coordinates\")[0];\n            if (coordsNode && coordsNode.textContent) {\n              const coordsText = coordsNode.textContent.trim();\n              const coordPairs = coordsText.split(/\\s+/); // Split by whitespace\n\n              coordPairs.forEach((pair) => {\n                const coords = pair.split(\",\");\n                if (coords.length >= 2) {\n                  const lon = parseFloat(coords[0]);\n                  const lat = parseFloat(coords[1]);\n\n                  if (!isNaN(lat) && !isNaN(lon)) {\n                    waypoints.push({ lat, lon });\n                  }\n                }\n              });\n            }\n          }\n        }\n      }\n\n      return waypoints;\n    },\n\n    // Placeholder for KMZ extraction (would need JSZip library for full implementation)\n    extractKMZ(kmzContent) {\n      return Promise.reject(\n        new Error(\"KMZ files are not supported yet. Convert to KML first.\")\n      );\n    },\n\n    // Add waypoints as targets to the map\n    addWaypointsAsTargets(waypoints) {\n      if (!waypoints || waypoints.length === 0) return;\n\n      state.targets = [];\n      document.getElementById(\"addedTargetsContainer\").innerHTML = \"\";\n\n      // Add waypoints as targets\n      waypoints.forEach((waypoint) => {\n        const newIndex = state.targets.length;\n        state.targets.push({ lat: waypoint.lat, lon: waypoint.lon });\n\n        // Create UI entry for target\n        targets.createTargetEntry(newIndex);\n      });\n\n      // Set the first imported waypoint as active\n      state.activeTargetIndex = state.targets.length - waypoints.length;\n\n      // Save targets and redraw\n      targets.saveTargets();\n      render.requestDraw();\n    },\n\n    // Setup event listeners for file import\n    setupGPXImport() {\n      const importBtn = document.getElementById(\"importGpx\");\n      const fileInput = document.getElementById(\"gpxFileInput\");\n\n      if (fileInput) {\n        // Update to accept KML files too\n        fileInput.accept = \".gpx,.kml,.kmz\";\n      }\n\n      if (importBtn && fileInput) {\n        importBtn.addEventListener(\"click\", () => {\n          fileInput.click();\n        });\n\n        fileInput.addEventListener(\"change\", async (event) => {\n          if (event.target.files.length === 0) return;\n\n          const file = event.target.files[0];\n          try {\n            const waypoints = await this.parseFile(file);\n            console.log(\n              `Imported ${waypoints.length} waypoints from ${file.name}`\n            );\n\n            if (waypoints.length === 0) {\n              console.log(\"No waypoints found in the file\");\n              return;\n            }\n\n            // Add the waypoints as targets\n            this.addWaypointsAsTargets(waypoints);\n          } catch (error) {\n            console.error(`Error importing file: ${error.message}`);\n          }\n\n          // Reset the file input so the same file can be selected again\n          fileInput.value = \"\";\n        });\n      }\n    },\n  };\n\n  // Public methods\n  return {\n    // Initialize the application\n    init() {\n      targets.setupNewTargetInput();\n      targets.loadTargets();\n      targets.setupDragAndDrop();\n      targets.addDragStyles();\n      events.setupEventListeners();\n      mavlink.setupListeners();\n      gpxImport.setupGPXImport();\n      render.startAnimationLoop();\n\n      helpers.resizeCanvas();\n    },\n  };\n})();\n\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", () => ROVMap.init());\n} else {\n  ROVMap.init();\n}\n"
}